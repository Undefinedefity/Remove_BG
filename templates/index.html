<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remove BG</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f1f5f9;
            margin: 0;
            padding: 2rem;
            color: #0f172a;
        }
        main {
            max-width: 640px;
            margin: 0 auto;
            background: #fff;
            border-radius: 18px;
            padding: 2rem;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
        }
        h1 {
            margin-top: 0;
            font-size: 2rem;
        }
        form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        input[type="file"] {
            border: 2px dashed #94a3b8;
            padding: 1rem;
            border-radius: 12px;
            background: #f8fafc;
        }
        button {
            border: none;
            border-radius: 999px;
            padding: 0.9rem;
            font-weight: 600;
            background: #2563eb;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        button:hover {
            background: #1d4ed8;
        }
        .result {
            margin-top: 2rem;
        }
        .canvas-wrapper {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            background: repeating-conic-gradient(#e2e8f0 0% 25%, transparent 0% 50%) 0 0/24px 24px;
            border: 1px solid #e2e8f0;
        }
        canvas {
            display: block;
            width: 100%;
            height: auto;
        }
        .editor {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }
        .editor-controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .brush {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            font-size: 0.9rem;
            color: #475569;
        }
        .brush input[type="range"] {
            width: 100%;
        }
        .brush output {
            font-weight: 600;
            color: #0f172a;
        }
        .mode-buttons {
            display: flex;
            gap: 0.5rem;
        }
        .mode-button {
            flex: 1;
            border-radius: 999px;
            border: 1px solid #cbd5f5;
            background: #e2e8f0;
            color: #0f172a;
            padding: 0.65rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }
        .mode-button.active {
            background: #2563eb;
            color: #fff;
            border-color: #2563eb;
        }
        .editor-actions {
            display: flex;
            justify-content: space-between;
            gap: 0.5rem;
        }
        .editor-actions button {
            flex: 1;
        }
        .ghost {
            background: #e2e8f0;
            color: #0f172a;
        }
        .ghost:hover {
            background: #cbd5f5;
        }
        .download-row {
            margin-top: 1rem;
        }
        .download {
            margin-top: 1rem;
            display: inline-block;
            padding: 0.75rem 1.5rem;
            border-radius: 999px;
            background: #10b981;
            color: #fff;
            text-decoration: none;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <main>
        <h1>Remove Background</h1>
        <p>Upload an image and get a transparent PNG with the background removed.</p>
        <form action="/remove" method="post" enctype="multipart/form-data">
            <input type="file" name="file" accept="image/*" required>
            <button type="submit">Process</button>
        </form>

        {% if result_image %}
        <section class="result">
            <h2>Result</h2>
            <p>Use the brush to fine-tune which areas remain visible.</p>
            <div id="editor-root" class="editor"
                 data-original="{{ original_image | e }}"
                 data-result="{{ result_image | e }}"
                 data-file-name="{{ file_name | e }}">
                <div class="canvas-wrapper">
                    <canvas id="previewCanvas"></canvas>
                </div>
                <div class="editor-controls">
                    <label class="brush">
                        <span>Brush size</span>
                        <input type="range" id="brushSize" min="5" max="120" value="40">
                        <output id="brushSizeValue">40 px</output>
                    </label>
                    <div class="mode-buttons">
                        <button type="button" class="mode-button active" data-mode="restore">Restore</button>
                        <button type="button" class="mode-button" data-mode="erase">Erase</button>
                    </div>
                    <div class="editor-actions">
                        <button type="button" class="ghost" id="resetMask">Reset</button>
                        <button type="button" id="downloadEdited">Download Edited PNG</button>
                    </div>
                </div>
            </div>
            <div class="download-row">
                <a class="download" href="{{ result_image }}" download="{{ file_name }}">Download Original Result</a>
            </div>
        </section>
        {% endif %}
    </main>
    <script>
    (function () {
        const editor = document.getElementById("editor-root");
        if (!editor) {
            return;
        }

        const previewCanvas = document.getElementById("previewCanvas");
        const previewCtx = previewCanvas.getContext("2d", { willReadFrequently: true });
        const modeButtons = Array.from(editor.querySelectorAll(".mode-button"));
        const brushSizeInput = document.getElementById("brushSize");
        const brushSizeValue = document.getElementById("brushSizeValue");
        const downloadBtn = document.getElementById("downloadEdited");
        const resetBtn = document.getElementById("resetMask");

        const state = {
            width: 0,
            height: 0,
            maskData: null,
            initialMask: null,
            originalPixels: null,
            drawing: false,
            brushSize: Number(brushSizeInput.value) || 40,
            mode: "restore",
        };

        const originalSrc = editor.dataset.original;
        const resultSrc = editor.dataset.result;
        const fileName = editor.dataset.fileName || "result.png";
        brushSizeValue.textContent = `${state.brushSize} px`;
        previewCanvas.style.touchAction = "none";

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        Promise.all([loadImage(originalSrc), loadImage(resultSrc)])
            .then(([originalImage, resultImage]) => {
                state.width = resultImage.width;
                state.height = resultImage.height;

                previewCanvas.width = state.width;
                previewCanvas.height = state.height;

                const helperOptions = { willReadFrequently: true };
                const originalCanvas = document.createElement("canvas");
                originalCanvas.width = state.width;
                originalCanvas.height = state.height;
                const originalCtx = originalCanvas.getContext("2d", helperOptions);
                originalCtx.drawImage(originalImage, 0, 0, state.width, state.height);
                const originalImageData = originalCtx.getImageData(0, 0, state.width, state.height);
                state.originalPixels = originalImageData.data;

                const tempCanvas = document.createElement("canvas");
                tempCanvas.width = state.width;
                tempCanvas.height = state.height;
                const tempCtx = tempCanvas.getContext("2d", helperOptions);
                tempCtx.drawImage(resultImage, 0, 0, state.width, state.height);
                const resultImageData = tempCtx.getImageData(0, 0, state.width, state.height);

                state.maskData = new Uint8ClampedArray(state.width * state.height);
                for (let i = 0; i < state.maskData.length; i += 1) {
                    state.maskData[i] = resultImageData.data[i * 4 + 3];
                }
                state.initialMask = new Uint8ClampedArray(state.maskData);

                const previewImageData = previewCtx.createImageData(state.width, state.height);
                function renderPreview() {
                    if (!state.maskData || !state.originalPixels) {
                        return;
                    }
                    const dst = previewImageData.data;
                    const src = state.originalPixels;
                    for (let i = 0; i < state.maskData.length; i += 1) {
                        const offset = i * 4;
                        dst[offset] = src[offset];
                        dst[offset + 1] = src[offset + 1];
                        dst[offset + 2] = src[offset + 2];
                        dst[offset + 3] = state.maskData[i];
                    }
                    previewCtx.putImageData(previewImageData, 0, 0);
                }

                function getPointerPosition(evt) {
                    const rect = previewCanvas.getBoundingClientRect();
                    const scaleX = state.width / rect.width;
                    const scaleY = state.height / rect.height;
                    return {
                        x: (evt.clientX - rect.left) * scaleX,
                        y: (evt.clientY - rect.top) * scaleY,
                    };
                }

                function applyBrush(position) {
                    if (!state.maskData) {
                        return;
                    }
                    const radius = state.brushSize;
                    const radiusSq = radius * radius;
                    const minX = Math.max(0, Math.floor(position.x - radius));
                    const maxX = Math.min(state.width - 1, Math.ceil(position.x + radius));
                    const minY = Math.max(0, Math.floor(position.y - radius));
                    const maxY = Math.min(state.height - 1, Math.ceil(position.y + radius));
                    const fillValue = state.mode === "restore" ? 255 : 0;

                    for (let y = minY; y <= maxY; y += 1) {
                        const dy = y - position.y;
                        for (let x = minX; x <= maxX; x += 1) {
                            const dx = x - position.x;
                            if (dx * dx + dy * dy <= radiusSq) {
                                state.maskData[y * state.width + x] = fillValue;
                            }
                        }
                    }
                    renderPreview();
                }

                function handlePointerDown(evt) {
                    evt.preventDefault();
                    state.drawing = true;
                    previewCanvas.setPointerCapture(evt.pointerId);
                    applyBrush(getPointerPosition(evt));
                }

                function handlePointerMove(evt) {
                    if (!state.drawing) {
                        return;
                    }
                    evt.preventDefault();
                    applyBrush(getPointerPosition(evt));
                }

                function stopDrawing(evt) {
                    if (!state.drawing) {
                        return;
                    }
                    evt.preventDefault();
                    state.drawing = false;
                    if (previewCanvas.hasPointerCapture(evt.pointerId)) {
                        previewCanvas.releasePointerCapture(evt.pointerId);
                    }
                }

                previewCanvas.addEventListener("pointerdown", handlePointerDown);
                previewCanvas.addEventListener("pointermove", handlePointerMove);
                previewCanvas.addEventListener("pointerup", stopDrawing);
                previewCanvas.addEventListener("pointerleave", stopDrawing);

                renderPreview();

                if (resetBtn) {
                    resetBtn.addEventListener("click", () => {
                        state.maskData.set(state.initialMask);
                        renderPreview();
                    });
                }

                if (downloadBtn) {
                    downloadBtn.addEventListener("click", () => {
                        renderPreview();
                        const a = document.createElement("a");
                        const safeName =
                            (fileName.replace(/\.[^.]+$/, "") || "result") + "_edited.png";
                        a.href = previewCanvas.toDataURL("image/png");
                        a.download = safeName;
                        a.click();
                    });
                }

                brushSizeInput.addEventListener("input", (evt) => {
                    const size = Number(evt.target.value) || 1;
                    state.brushSize = size;
                    brushSizeValue.textContent = `${size} px`;
                });

                modeButtons.forEach((button) => {
                    button.addEventListener("click", () => {
                        state.mode = button.dataset.mode;
                        modeButtons.forEach((btn) => btn.classList.remove("active"));
                        button.classList.add("active");
                    });
                });
            })
            .catch((error) => {
                console.error("Failed to initialize editor", error);
            });
    })();
    </script>
</body>
</html>
